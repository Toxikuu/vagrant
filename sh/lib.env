#!/usr/bin/env false
#shellcheck shell=bash

CURL="curl -fsSL --max-time 128 --connect-timeout=8 --retry=4 --retry-all-errors --retry-delay=2"

# run the script associated with the current channel
script() {
    "scripts/$channel"
}

# private helper function to query the github api
_ghapi() {
    hash=$(printf %s "${1:?}" | sha256sum | cut -d\  -f1)
    cache="$VAGRANT_CACHE/ghapi-$hash"

    if [ ! -r "$cache" ] || [ ! -s "$cache" ] || "$NO_CACHE" ; then
        if [ -n "$GH_TOKEN" ]; then
            $CURL \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                -H "Authorization: Bearer $GH_TOKEN" \
                "$1" | install -Dm644 /dev/stdin "$cache"
        else
            $CURL \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "$1" | install -Dm644 /dev/stdin "$cache"
        fi
    fi

    cat "$cache"
}

# fetch latest github release that isn't a pre-release. if no releases are
# present, fall back to tags with `gr`.
ghr() {
    url="https://api.github.com/repos/${shortform:?}/releases?per_page=10&page=1"
    ver="$(_ghapi "$url" | jq -r 'first(.[] | select(.prerelease == false)).tag_name')"

    if [ -z "$ver" ]; then
        ver="$(defgitrelease)"
    fi

    printf "%s" "$ver"
}

# fetch latest github commit
ghc() {
    url="https://api.github.com/repos/${shortform:?}/commits?per_page=1&page=1"
    _ghapi "$url" | jq -r ".[0].sha"
}

# lowercase input
tolower() {
    tr '[:upper:]' '[:lower:]'
}

# uppercase input
toupper() {
    tr '[:lower:]' '[:upper:]'
}

# private helper function serving as the backend for `gr` and `githead`
_gitremote() {
    hash=$(printf %s "${upstream:?}" | sha256sum | cut -d\  -f1)
    cache="$VAGRANT_CACHE/git-$hash"

    # cursed avoidance of git so we can use curl with our flags
    if [ ! -r "$cache" ] || [ ! -s "$cache" ] || "$NO_CACHE" ; then
        $CURL "${upstream%/}/info/refs?service=git-upload-pack" |
            grep -aEo '[a-f0-9]{40}\s+.+[^\^\{\}]$' |
            cut -d $'\0' -f1 |
            sed 's,\t, ,' |
            install -Dm644 /dev/stdin "$cache"
    fi

    printf %s "$cache"
}

# git list remote tags (with caching)
gr() {
    local cache="$(_gitremote)"
    grep -F refs/tags/ "$cache" | sed -e 's,.*/,,' -e '/\^{}$/d'
}

# retrieve latest commit
githead() {
    local cache="$(_gitremote)"
    head -n1 "$cache" | cut -d\  -f1
}

# version filter stable
vfs() {
    grep -Eiv "rc|dev|beta|alpha|pre|${1:-DUMMY}"
}

# trim versions
vtrim() {
    # case insensitive for all operations
    # 1. trim name with an optional delimiter of - or _
    # 2. trim release with an optional delimiter of - or _
    # 3. trim version prefixes v, r, n
    # 4. replace all underscores between numbers with dots
    sed -re "s,^${name:?}[-_]?,,I"           \
        -e  "s,^release[-_],,I"              \
        -e  "s,^[vrn]([0-9]),\1,"            \
        -e  ":a; s,([0-9]+)_([0-9]+),\1.\2,g; ta" \
        "$@"
}

# version filter even minor
vfem() {
    awk -F. '/[0-9]+\.[0-9]+\.[0-9]+/ { if ($2 % 2 == 0) print }'
}

# grep for a commit
commitgrep() {
    grep -E '[a-f0-9]{40}' "$@"
}

# grep for a version with a prefix and n parts
#
# prefix: ${2-}
# n: ${1:-0} (0 means 2 or 3 parts; up to 5 parts supported)
vrep() {
    local parts prefix suffix

    while [ $# -gt 0 ]; do
        case "$1" in
            -[0-5])
                parts="${1#-}"
                shift 1
            ;;
            -a | -p )
                prefix="${2:?prefix not specified}"
                shift 2
            ;;
            -z | -s )
                suffix="${2:?suffix not specified}"
                shift 2
            ;;
            -- )
                shift
                break
            ;;
            *  )
                echo "vrep: unknown option: $1" >&2
                return 1
            ;;
        esac
    done

    local parts="${parts:-0}"
    local prefix="${prefix-}"
    local suffix="${suffix-}"
    case $parts in
        0) grep -P "$@" -- "$prefix[0-9]+(\.[0-9]+)+$suffix" ;;
        1) grep -P "$@" -- "$prefix[0-9]+$suffix" ;;
        2) grep -P "$@" -- "$prefix[0-9]+\.[0-9]+$suffix" ;;
        3) grep -P "$@" -- "$prefix[0-9]+\.[0-9]+\.[0-9]+$suffix" ;;
        4) grep -P "$@" -- "$prefix[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$suffix" ;;
        5) grep -P "$@" -- "$prefix[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$suffix" ;;
        *) echo "vrep: unsupported number of parts" >&2 ; exit 1 ;;
    esac
}

# vrep but match an entire line
vrepl() {
    vrep -a '^' -z '$' "$@"
}

# vrep but only return match
vrepo() {
    vrep "$@" -- -o
}

# prepend dashes to prerelease labels that may be missing them
predash() {
    sed -E \
        -e 's,([0-9])(pre),\1-\2,'   \
        -e 's,([0-9])(rc),\1-\2,'    \
        -e 's,([0-9])(dev),\1-\2,'   \
        -e 's,([0-9])(alpha),\1-\2,' \
        -e 's,([0-9])(beta),\1-\2,'
}

# filter out lines starting with letters
fsl() {
    grep -v '^[a-zA-Z]'
}

# filter out lines with letters
fl() {
    grep -v '[a-zA-Z]'
}

# filter out lines containing no digits
fnd() {
    grep '[0-9]'
}

# filter out lines containing dashes
fdash() {
    grep -vF -- -
}

# filter out lines with dates
fdate() {
    grep -Ev '[0-9]{4}-?[0-9]{2}-?[0-9]{2}'
}

# filter out lines that consist only of dates
fdatel() {
    grep -Ev '^[0-9]{4}-?[0-9]{2}-?[0-9]{2}$'
}

# filter out lines containing CVEs
fcve() {
    grep -vF -- CVE-
}

# version sort
vsort() {
    versort -i "$@" | uniq
}

# curl upstream
cr() {
    hash=$(printf %s "${upstream:?}" | sha256sum | cut -d\  -f1)
    cache="$VAGRANT_CACHE/curl-$hash"

    if [ ! -r "$cache" ] || [ ! -s "$cache" ] || "$NO_CACHE" ; then
        $CURL "${upstream:?}" |
            install -Dm644 /dev/stdin "$cache"
    fi

    cat "$cache"
}

# curl upstream automagically
ca() {
    cr | vrepo -a "$name[-_]?" -z '.*?\.t' | vtrim -e 's,\.t$,,'
}

# get version from arch packages or aur (upstream should be the arch package
# page)
archver() {
    if echo "$upstream" | grep -F 'aur.archlinux.org'; then
        cr | jq -r '.Version' | cut -d- -f1
    else
        cr | jq -r '.pkgver'
    fi
}

# default git release
defgitrelease() {
    gr | vtrim | fsl | vfs | vsort
}

# default git unstable
defgitunstable() {
    gr | vtrim | fsl | vsort
}

# default git commit
defgitcommit() {
    githead
}

# default curl releaese
defcurlrelease() {
    ca | fdash | vsort | vfs
}

# default curl unstable
defcurlunstable() {
    ca | vsort
}

defcurlcommit() {
    cr | commitgrep -o
}
